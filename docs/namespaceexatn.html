<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ExaTN: exatn Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ExaTN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">exatn Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1_cloneable.html">Cloneable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1_identifiable.html">Identifiable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexatn_1_1_index_label.html">IndexLabel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1_num_server.html">NumServer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1_service_registry.html">ServiceRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9926f7f07ff9b745e497dededd6329ad"><td class="memItemLeft" align="right" valign="top"><a id="a9926f7f07ff9b745e497dededd6329ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TensorMethod</b> = talsh::TensorFunctor&lt; <a class="el" href="classexatn_1_1_identifiable.html">Identifiable</a> &gt;</td></tr>
<tr class="separator:a9926f7f07ff9b745e497dededd6329ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475c43951b2665a9a190fb733223ecb9"><td class="memItemLeft" align="right" valign="top"><a id="a475c43951b2665a9a190fb733223ecb9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Int4</b> = int32_t</td></tr>
<tr class="separator:a475c43951b2665a9a190fb733223ecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70e036fe142b81e5f266a694ac0add4"><td class="memItemLeft" align="right" valign="top"><a id="aa70e036fe142b81e5f266a694ac0add4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Int8</b> = int64_t</td></tr>
<tr class="separator:aa70e036fe142b81e5f266a694ac0add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b73a217f25a00f978c06dc07a658bf2"><td class="memItemLeft" align="right" valign="top"><a id="a8b73a217f25a00f978c06dc07a658bf2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UInt4</b> = uint32_t</td></tr>
<tr class="separator:a8b73a217f25a00f978c06dc07a658bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8914ee57f43234c4e0cf07ae1bcd75d4"><td class="memItemLeft" align="right" valign="top"><a id="a8914ee57f43234c4e0cf07ae1bcd75d4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UInt8</b> = uint64_t</td></tr>
<tr class="separator:a8914ee57f43234c4e0cf07ae1bcd75d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa474cf7c0c9adf5d19e139b5a3f8a103"><td class="memItemLeft" align="right" valign="top"><a id="aa474cf7c0c9adf5d19e139b5a3f8a103"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SpaceId</b> = unsigned int</td></tr>
<tr class="separator:aa474cf7c0c9adf5d19e139b5a3f8a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30d65e3826e2c2f6049c45dfcc233f4"><td class="memItemLeft" align="right" valign="top"><a id="ad30d65e3826e2c2f6049c45dfcc233f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SubspaceId</b> = unsigned long long int</td></tr>
<tr class="separator:ad30d65e3826e2c2f6049c45dfcc233f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef79a344aca6d19b1a433e5f552a996"><td class="memItemLeft" align="right" valign="top"><a id="a2ef79a344aca6d19b1a433e5f552a996"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SymmetryId</b> = int</td></tr>
<tr class="separator:a2ef79a344aca6d19b1a433e5f552a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9d6fdbef114b2efc42b82228ade136"><td class="memItemLeft" align="right" valign="top"><a id="a0e9d6fdbef114b2efc42b82228ade136"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DimExtent</b> = unsigned long long int</td></tr>
<tr class="separator:a0e9d6fdbef114b2efc42b82228ade136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf4e645f8b20a27525f6c602424ad31"><td class="memItemLeft" align="right" valign="top"><a id="acaf4e645f8b20a27525f6c602424ad31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DimOffset</b> = unsigned long long int</td></tr>
<tr class="separator:acaf4e645f8b20a27525f6c602424ad31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d966de55a53fbc22fd3e6e91db0e53"><td class="memItemLeft" align="right" valign="top"><a id="a69d966de55a53fbc22fd3e6e91db0e53"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ScopeId</b> = unsigned int</td></tr>
<tr class="separator:a69d966de55a53fbc22fd3e6e91db0e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa120b358bc88008ee5b3a014e3771a98"><td class="memItemLeft" align="right" valign="top"><a id="aa120b358bc88008ee5b3a014e3771a98"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>LegDirection</b> { <b>UNDIRECT</b>, 
<b>INWARD</b>, 
<b>OUTWARD</b>
 }</td></tr>
<tr class="separator:aa120b358bc88008ee5b3a014e3771a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126d85c56f63614d0111e2d20f5b3a48"><td class="memItemLeft" align="right" valign="top"><a id="a126d85c56f63614d0111e2d20f5b3a48"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TensorOpCode</b> { <br />
&#160;&#160;<b>NOOP</b>, 
<b>CREATE</b>, 
<b>DESTROY</b>, 
<b>TRANSFORM</b>, 
<br />
&#160;&#160;<b>ADD</b>, 
<b>CONTRACT</b>
<br />
 }</td></tr>
<tr class="separator:a126d85c56f63614d0111e2d20f5b3a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0542438ec0c965e5579667204d99c804"><td class="memItemLeft" align="right" valign="top"><a id="a0542438ec0c965e5579667204d99c804"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TensorElementType</b> { <br />
&#160;&#160;<b>VOID</b>, 
<b>REAL16</b>, 
<b>REAL32</b>, 
<b>REAL64</b>, 
<br />
&#160;&#160;<b>COMPLEX16</b>, 
<b>COMPLEX32</b>, 
<b>COMPLEX64</b>
<br />
 }</td></tr>
<tr class="separator:a0542438ec0c965e5579667204d99c804"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab550fa106525e19be9a64935d268fc1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#ab550fa106525e19be9a64935d268fc1d">initialize</a> ()</td></tr>
<tr class="separator:ab550fa106525e19be9a64935d268fc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387de899852d3210f660e682dc6a6430"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a387de899852d3210f660e682dc6a6430">isInitialized</a> ()</td></tr>
<tr class="separator:a387de899852d3210f660e682dc6a6430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd92b4f4f0e1d9d2506356f3b0bea10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a6fd92b4f4f0e1d9d2506356f3b0bea10">finalize</a> ()</td></tr>
<tr class="separator:a6fd92b4f4f0e1d9d2506356f3b0bea10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1df2c9622ad4a0d42f511a7e4adccb"><td class="memItemLeft" align="right" valign="top">ScopeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a2a1df2c9622ad4a0d42f511a7e4adccb">openScope</a> (const std::string &amp;scope_name)</td></tr>
<tr class="separator:a2a1df2c9622ad4a0d42f511a7e4adccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4b202ad14cc3dfab51344bcabbaac8"><td class="memItemLeft" align="right" valign="top">ScopeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a4c4b202ad14cc3dfab51344bcabbaac8">closeScope</a> ()</td></tr>
<tr class="separator:a4c4b202ad14cc3dfab51344bcabbaac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dc38482f24343564a16e08609775b9"><td class="memItemLeft" align="right" valign="top">SpaceId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#ad3dc38482f24343564a16e08609775b9">createVectorSpace</a> (const std::string &amp;space_name, DimExtent space_dim, const <a class="el" href="classexatn_1_1numerics_1_1_vector_space.html">VectorSpace</a> **space_ptr=nullptr)</td></tr>
<tr class="separator:ad3dc38482f24343564a16e08609775b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac890d1557b624fd402aa6e0d1cef0892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#ac890d1557b624fd402aa6e0d1cef0892">destroyVectorSpace</a> (const std::string &amp;space_name)</td></tr>
<tr class="separator:ac890d1557b624fd402aa6e0d1cef0892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65aaaeab1e1cc84fe7c7fd2b9c37a337"><td class="memItemLeft" align="right" valign="top"><a id="a65aaaeab1e1cc84fe7c7fd2b9c37a337"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroyVectorSpace</b> (SpaceId space_id)</td></tr>
<tr class="separator:a65aaaeab1e1cc84fe7c7fd2b9c37a337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0547f5ec3f31241b4e40bf2ce9214503"><td class="memItemLeft" align="right" valign="top">SubspaceId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a0547f5ec3f31241b4e40bf2ce9214503">createSubspace</a> (const std::string &amp;subspace_name, const std::string &amp;space_name, const std::pair&lt; DimOffset, DimOffset &gt; bounds, const <a class="el" href="classexatn_1_1numerics_1_1_subspace.html">Subspace</a> **subspace_ptr=nullptr)</td></tr>
<tr class="separator:a0547f5ec3f31241b4e40bf2ce9214503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62396b5a34699a0e926b4ea7e0b74754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a62396b5a34699a0e926b4ea7e0b74754">destroySubspace</a> (const std::string &amp;subspace_name)</td></tr>
<tr class="separator:a62396b5a34699a0e926b4ea7e0b74754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82fc9d453fee2c9ae5f0ac673ba6269"><td class="memItemLeft" align="right" valign="top"><a id="ac82fc9d453fee2c9ae5f0ac673ba6269"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroySubspace</b> (SubspaceId subspace_id)</td></tr>
<tr class="separator:ac82fc9d453fee2c9ae5f0ac673ba6269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaf7496e85cf32c9527446a301a0d7e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classexatn_1_1numerics_1_1_subspace.html">Subspace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#aaaaf7496e85cf32c9527446a301a0d7e">getSubspace</a> (const std::string &amp;subspace_name)</td></tr>
<tr class="separator:aaaaf7496e85cf32c9527446a301a0d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5f19d66b02decec304d8129342ac51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a4c5f19d66b02decec304d8129342ac51">registerTensorMethod</a> (const std::string &amp;tag, std::shared_ptr&lt; TensorMethod &gt; method)</td></tr>
<tr class="separator:a4c5f19d66b02decec304d8129342ac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b240460e27c268690079df15a59d61"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; TensorMethod &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a32b240460e27c268690079df15a59d61">getTensorMethod</a> (const std::string &amp;tag)</td></tr>
<tr class="separator:a32b240460e27c268690079df15a59d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e70ee2bed4171c189d6959369c11d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a6e70ee2bed4171c189d6959369c11d21">registerExternalData</a> (const std::string &amp;tag, std::shared_ptr&lt; BytePacket &gt; packet)</td></tr>
<tr class="separator:a6e70ee2bed4171c189d6959369c11d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a798d344b2b0498e9b391beb75d5ab"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; BytePacket &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#ad4a798d344b2b0498e9b391beb75d5ab">getExternalData</a> (const std::string &amp;tag)</td></tr>
<tr class="separator:ad4a798d344b2b0498e9b391beb75d5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b73d905fe974d4aa76b0548f4d4d81"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae2b73d905fe974d4aa76b0548f4d4d81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#ae2b73d905fe974d4aa76b0548f4d4d81">createTensor</a> (const std::string &amp;name, TensorElementType element_type, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ae2b73d905fe974d4aa76b0548f4d4d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8760dfed39e702de8bcd47a7d993d9b"><td class="memTemplParams" colspan="2"><a id="ae8760dfed39e702de8bcd47a7d993d9b"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae8760dfed39e702de8bcd47a7d993d9b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createTensorSync</b> (const std::string &amp;name, TensorElementType element_type, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ae8760dfed39e702de8bcd47a7d993d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4bc55caa2a969395346eb2a631f451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a0a4bc55caa2a969395346eb2a631f451">getTensorRef</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a0a4bc55caa2a969395346eb2a631f451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fb913109ede1f468b042e4cadab54d"><td class="memItemLeft" align="right" valign="top">TensorElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#af5fb913109ede1f468b042e4cadab54d">getTensorElementType</a> (const std::string &amp;name)</td></tr>
<tr class="separator:af5fb913109ede1f468b042e4cadab54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee1c97d99ad2562cd8b01d992b49983"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a6ee1c97d99ad2562cd8b01d992b49983">destroyTensor</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a6ee1c97d99ad2562cd8b01d992b49983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca2608564a2b137d47fdecc742e98a5"><td class="memItemLeft" align="right" valign="top"><a id="aeca2608564a2b137d47fdecc742e98a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>destroyTensorSync</b> (const std::string &amp;name)</td></tr>
<tr class="separator:aeca2608564a2b137d47fdecc742e98a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b523e619187267d1e0d1b27f223176"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:aa9b523e619187267d1e0d1b27f223176"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#aa9b523e619187267d1e0d1b27f223176">initTensor</a> (const std::string &amp;name, NumericType value)</td></tr>
<tr class="separator:aa9b523e619187267d1e0d1b27f223176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3750ba87325f404be3a50e54816005"><td class="memTemplParams" colspan="2"><a id="a0c3750ba87325f404be3a50e54816005"></a>
template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a0c3750ba87325f404be3a50e54816005"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initTensorSync</b> (const std::string &amp;name, NumericType value)</td></tr>
<tr class="separator:a0c3750ba87325f404be3a50e54816005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d4ce03b21b91126d7381ea5fc318b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a71d4ce03b21b91126d7381ea5fc318b8">transformTensor</a> (const std::string &amp;name, std::shared_ptr&lt; TensorMethod &gt; functor)</td></tr>
<tr class="separator:a71d4ce03b21b91126d7381ea5fc318b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200bff4940089f7387241127cecf939d"><td class="memItemLeft" align="right" valign="top"><a id="a200bff4940089f7387241127cecf939d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>transformTensorSync</b> (const std::string &amp;name, std::shared_ptr&lt; TensorMethod &gt; functor)</td></tr>
<tr class="separator:a200bff4940089f7387241127cecf939d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016e6da532f7a0b0cdcfaecd7c03b691"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a016e6da532f7a0b0cdcfaecd7c03b691"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a016e6da532f7a0b0cdcfaecd7c03b691">addTensors</a> (const std::string &amp;addition, NumericType alpha)</td></tr>
<tr class="separator:a016e6da532f7a0b0cdcfaecd7c03b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd228cea332ab88f9823d2f5ea2fcb8"><td class="memTemplParams" colspan="2"><a id="afbd228cea332ab88f9823d2f5ea2fcb8"></a>
template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:afbd228cea332ab88f9823d2f5ea2fcb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addTensorsSync</b> (const std::string &amp;addition, NumericType alpha)</td></tr>
<tr class="separator:afbd228cea332ab88f9823d2f5ea2fcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090bcde53c17135a666ca7bcb7d61514"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a090bcde53c17135a666ca7bcb7d61514"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a090bcde53c17135a666ca7bcb7d61514">contractTensors</a> (const std::string &amp;contraction, NumericType alpha)</td></tr>
<tr class="separator:a090bcde53c17135a666ca7bcb7d61514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9076276a4a10b06d6704d96fa1e367a1"><td class="memTemplParams" colspan="2"><a id="a9076276a4a10b06d6704d96fa1e367a1"></a>
template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a9076276a4a10b06d6704d96fa1e367a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contractTensorsSync</b> (const std::string &amp;contraction, NumericType alpha)</td></tr>
<tr class="separator:a9076276a4a10b06d6704d96fa1e367a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba81ab31482f2d11c2b682c7d71960a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#aaba81ab31482f2d11c2b682c7d71960a">evaluateTensorNetwork</a> (const std::string &amp;name, const std::string &amp;network)</td></tr>
<tr class="separator:aaba81ab31482f2d11c2b682c7d71960a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0868b037e8d53135729162aff75243"><td class="memItemLeft" align="right" valign="top"><a id="a5a0868b037e8d53135729162aff75243"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>evaluateTensorNetworkSync</b> (const std::string &amp;name, const std::string &amp;network)</td></tr>
<tr class="separator:a5a0868b037e8d53135729162aff75243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9fb65f20c69d23cdf69b4f3acf9ed1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a6b9fb65f20c69d23cdf69b4f3acf9ed1">sync</a> (const std::string &amp;name, bool wait=true)</td></tr>
<tr class="separator:a6b9fb65f20c69d23cdf69b4f3acf9ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0068c03bc225d84db8f1ca68ae840eb3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; talsh::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a0068c03bc225d84db8f1ca68ae840eb3">getLocalTensor</a> (std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt; tensor, const std::vector&lt; std::pair&lt; DimOffset, DimExtent &gt;&gt; &amp;slice_spec)</td></tr>
<tr class="separator:a0068c03bc225d84db8f1ca68ae840eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135a68e018004d809489c7a6aeed80fb"><td class="memItemLeft" align="right" valign="top"><a id="a135a68e018004d809489c7a6aeed80fb"></a>
std::shared_ptr&lt; talsh::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLocalTensor</b> (const std::string &amp;name, const std::vector&lt; std::pair&lt; DimOffset, DimExtent &gt;&gt; &amp;slice_spec)</td></tr>
<tr class="separator:a135a68e018004d809489c7a6aeed80fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8317ca78b14fbd5ea6767f4770223"><td class="memItemLeft" align="right" valign="top"><a id="a4ec8317ca78b14fbd5ea6767f4770223"></a>
std::shared_ptr&lt; talsh::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getLocalTensor</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a4ec8317ca78b14fbd5ea6767f4770223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b4de20386d3fc968baadd35eecd88c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a93b4de20386d3fc968baadd35eecd88c">resetRuntimeLoggingLevel</a> (int level=0)</td></tr>
<tr class="separator:a93b4de20386d3fc968baadd35eecd88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e02e1734a0e34f421426e3149d5db55"><td class="memTemplParams" colspan="2"><a id="a6e02e1734a0e34f421426e3149d5db55"></a>
template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a6e02e1734a0e34f421426e3149d5db55"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; Service &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getService</b> (const std::string &amp;serviceName)</td></tr>
<tr class="separator:a6e02e1734a0e34f421426e3149d5db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ec6e12fb78d737239aa00d242e6e1a"><td class="memTemplParams" colspan="2"><a id="a47ec6e12fb78d737239aa00d242e6e1a"></a>
template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a47ec6e12fb78d737239aa00d242e6e1a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hasService</b> (const std::string &amp;serviceName)</td></tr>
<tr class="separator:a47ec6e12fb78d737239aa00d242e6e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18baacd5677ab45ac9a9e1a9fc65479b"><td class="memTemplParams" colspan="2"><a id="a18baacd5677ab45ac9a9e1a9fc65479b"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a18baacd5677ab45ac9a9e1a9fc65479b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">numerics::Tensor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeSharedTensor</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a18baacd5677ab45ac9a9e1a9fc65479b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4523ad427fdd8dbaaeae66e4ed8cc5"><td class="memTemplParams" colspan="2"><a id="acc4523ad427fdd8dbaaeae66e4ed8cc5"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acc4523ad427fdd8dbaaeae66e4ed8cc5"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">numerics::TensorNetwork</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeSharedTensorNetwork</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:acc4523ad427fdd8dbaaeae66e4ed8cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac376ebab37a06ba798a1a3510e51e47a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#ac376ebab37a06ba798a1a3510e51e47a">parse_tensor</a> (const std::string &amp;tensor, std::string &amp;tensor_name, std::vector&lt; <a class="el" href="structexatn_1_1_index_label.html">IndexLabel</a> &gt; &amp;indices, bool &amp;complex_conjugated)</td></tr>
<tr class="separator:ac376ebab37a06ba798a1a3510e51e47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa525a333d893eb552bf62eb6a408948b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#aa525a333d893eb552bf62eb6a408948b">parse_tensor_network</a> (const std::string &amp;network, std::vector&lt; std::string &gt; &amp;tensors)</td></tr>
<tr class="separator:aa525a333d893eb552bf62eb6a408948b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0510df740154601b225ca85e7dee38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a0d0510df740154601b225ca85e7dee38">generate_contraction_pattern</a> (const std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_leg.html">numerics::TensorLeg</a> &gt; &amp;pattern, unsigned int left_tensor_rank, unsigned int right_tensor_rank, std::string &amp;symb_pattern)</td></tr>
<tr class="separator:a0d0510df740154601b225ca85e7dee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca6a86b4b7a9ec6b5133cf6b159f204"><td class="memItemLeft" align="right" valign="top"><a id="a9ca6a86b4b7a9ec6b5133cf6b159f204"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_letter</b> (const char &amp;ch)</td></tr>
<tr class="separator:a9ca6a86b4b7a9ec6b5133cf6b159f204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536acfaa8b5567b4ad767c90a8f87f5d"><td class="memItemLeft" align="right" valign="top"><a id="a536acfaa8b5567b4ad767c90a8f87f5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_number</b> (const char &amp;ch)</td></tr>
<tr class="separator:a536acfaa8b5567b4ad767c90a8f87f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fab1ded8096a9c4dfaf1704cd4363c3"><td class="memItemLeft" align="right" valign="top"><a id="a5fab1ded8096a9c4dfaf1704cd4363c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_underscore</b> (const char &amp;ch)</td></tr>
<tr class="separator:a5fab1ded8096a9c4dfaf1704cd4363c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0654a6e6fb1c22973f793a847e8106"><td class="memItemLeft" align="right" valign="top"><a id="afe0654a6e6fb1c22973f793a847e8106"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_space</b> (const char &amp;ch)</td></tr>
<tr class="separator:afe0654a6e6fb1c22973f793a847e8106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693856a70de3d6f063bfdba4dc763381"><td class="memItemLeft" align="right" valign="top"><a id="a693856a70de3d6f063bfdba4dc763381"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_conjugation_sign</b> (const char &amp;ch)</td></tr>
<tr class="separator:a693856a70de3d6f063bfdba4dc763381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80d0b81b2ded97d6107b00a8c034f3e"><td class="memItemLeft" align="right" valign="top"><a id="ab80d0b81b2ded97d6107b00a8c034f3e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_equal_sign</b> (const char &amp;ch)</td></tr>
<tr class="separator:ab80d0b81b2ded97d6107b00a8c034f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf614608f3c07b88d9a60f0e26c2c2ef"><td class="memItemLeft" align="right" valign="top"><a id="aaf614608f3c07b88d9a60f0e26c2c2ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_plus_sign</b> (const char &amp;ch)</td></tr>
<tr class="separator:aaf614608f3c07b88d9a60f0e26c2c2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37bda46cda7d70e5c4709ac4545e970"><td class="memItemLeft" align="right" valign="top"><a id="af37bda46cda7d70e5c4709ac4545e970"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_minus_sign</b> (const char &amp;ch)</td></tr>
<tr class="separator:af37bda46cda7d70e5c4709ac4545e970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a293dcaeaeba8626f63d8ca6f4aac86"><td class="memItemLeft" align="right" valign="top"><a id="a4a293dcaeaeba8626f63d8ca6f4aac86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_multiply_sign</b> (const char &amp;ch)</td></tr>
<tr class="separator:a4a293dcaeaeba8626f63d8ca6f4aac86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5dacc9ac63031177dc1d1cba0d1a5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a1e5dacc9ac63031177dc1d1cba0d1a5f">is_alphanumeric</a> (const std::string &amp;identifier)</td></tr>
<tr class="separator:a1e5dacc9ac63031177dc1d1cba0d1a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443ef2ec833fd6bccf065aeb0b760d6d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a443ef2ec833fd6bccf065aeb0b760d6d">trim_spaces_off</a> (const std::string &amp;str, std::pair&lt; int, int &gt; view)</td></tr>
<tr class="separator:a443ef2ec833fd6bccf065aeb0b760d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acff06fcb8ea2f7e96079b53242e22733"><td class="memItemLeft" align="right" valign="top"><a id="acff06fcb8ea2f7e96079b53242e22733"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>exatnFrameworkInitialized</b> = false</td></tr>
<tr class="separator:acff06fcb8ea2f7e96079b53242e22733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04636254a2d42cb65055b1da931a6600"><td class="memItemLeft" align="right" valign="top"><a id="a04636254a2d42cb65055b1da931a6600"></a>
std::shared_ptr&lt; <a class="el" href="classexatn_1_1_service_registry.html">ServiceRegistry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>serviceRegistry</b> = std::make_shared&lt;<a class="el" href="classexatn_1_1_service_registry.html">ServiceRegistry</a>&gt;()</td></tr>
<tr class="separator:a04636254a2d42cb65055b1da931a6600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195b193ef5b91bdba6382ae874f93893"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classexatn_1_1_num_server.html">NumServer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexatn.html#a195b193ef5b91bdba6382ae874f93893">numericalServer</a> {nullptr}</td></tr>
<tr class="separator:a195b193ef5b91bdba6382ae874f93893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0724725e72de159067488c89998143"><td class="memItemLeft" align="right" valign="top"><a id="a0e0724725e72de159067488c89998143"></a>
constexpr DimExtent&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SPACE_DIM</b> = 0xFFFFFFFFFFFFFFFF</td></tr>
<tr class="separator:a0e0724725e72de159067488c89998143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a001ce1be6cdde38303a1342863ad8e"><td class="memItemLeft" align="right" valign="top"><a id="a8a001ce1be6cdde38303a1342863ad8e"></a>
constexpr SpaceId&#160;</td><td class="memItemRight" valign="bottom"><b>SOME_SPACE</b> = 0</td></tr>
<tr class="separator:a8a001ce1be6cdde38303a1342863ad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205d97f8b485a1d801c2137d57e056cf"><td class="memItemLeft" align="right" valign="top"><a id="a205d97f8b485a1d801c2137d57e056cf"></a>
constexpr SubspaceId&#160;</td><td class="memItemRight" valign="bottom"><b>FULL_SUBSPACE</b> = 0</td></tr>
<tr class="separator:a205d97f8b485a1d801c2137d57e056cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97724eaade341d6a0ae0070ba1ba70b7"><td class="memItemLeft" align="right" valign="top"><a id="a97724eaade341d6a0ae0070ba1ba70b7"></a>
constexpr SubspaceId&#160;</td><td class="memItemRight" valign="bottom"><b>UNREG_SUBSPACE</b> = 0xFFFFFFFFFFFFFFFF</td></tr>
<tr class="separator:a97724eaade341d6a0ae0070ba1ba70b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ExaTN::Numerics: General client header REVISION: 2019/10/13</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: 1. Vector space and subspace registration: (a) Any unnamed vector space is automatically associated with a preregistered anonymous vector space wtih id = SOME_SPACE = 0. (b) Any explicitly registered (named) vector space has id &gt; 0. (c) Any unregistered subspace of any named vector space has id = UNREG_SUBSPACE = max(uint64_t). (d) Every explicitly registered (named) vector space has an automatically registered full subspace (=space) under the same (space) name with id = FULL_SUBSPACE = 0. (e) Every registered non-trivial named subspace of any named vector space has id: 0 &lt; id &lt; max(uint64_t). (f) A subspace of the anonymous vector space is defined by the base offset (first basis vector belonging to it) and its dimension. 2. Index labels: (a) Any registered subspace can be assigned a symbolic index label serving as a placeholder for it; any index label can only refer to a single registered (named) subspace it is associated with.</p>
<p>ExaTN::Numerics: Numerical server REVISION: 2019/10/13</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Basis Vector REVISION: 2019/03/17</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Basis Vector REVISION: 2019/05/27</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Any basis vector spans a primitive 1-dimensional subspace; (b) Any space/subspace can be composed of linear-independent 1-dimensional subspaces by taking a direct sum of them. (c) Any abstract basis vector can further be specialized/concretized by introducing additional attributes peculiar to a specific basis kind.</p>
<p>ExaTN::Numerics: Tensor contraction sequence optimizer REVISION: 2019/10/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale:</p>
<p>ExaTN::Numerics: Tensor contraction sequence optimizer: Dummy REVISION: 2019/09/09</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor contraction sequence optimizer: Dummy REVISION: 2019/09/09</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale:</p>
<p>ExaTN::Numerics: Tensor contraction sequence optimizer factory REVISION: 2019/09/10</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor contraction sequence optimizer factory REVISION: 2019/09/10</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Creates tensor contraction sequence optimizers of desired kind.</p>
<p>ExaTN::Numerics: Tensor contraction sequence optimizer: Heuristics REVISION: 2019/10/02</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor contraction sequence optimizer: Heuristics REVISION: 2019/10/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale:</p>
<p>ExaTN::Numerics: Tensor Functor: Initialization to a scalar value REVISION: 2019/09/20</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor Functor: Initialization to a scalar value REVISION: 2019/09/20</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (A) This tensor functor (method) is used to initialize a Tensor to a scalar value, with the default of zero.</p>
<p>ExaTN::Numerics: Tensor network builder factory REVISION: 2019/11/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor network builder factory REVISION: 2019/11/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Creates tensor network builders of desired kind.</p>
<p>ExaTN::Numerics: Tensor network builder REVISION: 2019/11/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) A tensor network builder allows building complex tensor networks of a specific kind.</p>
<p>ExaTN::Numerics: Tensor network builder: MPS: Matrix Product State REVISION: 2019/11/05</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor network builder: MPS: Matrix Product State REVISION: 2019/11/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale:</p>
<p>ExaTN::Numerics: Tensor network builder: Tree: Tree Tensor Network REVISION: 2019/11/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor network builder: Tree: Tree Tensor Network REVISION: 2019/11/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale:</p>
<p>ExaTN::Numerics: Space Basis REVISION: 2019/03/18</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Space Basis REVISION: 2019/05/27</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Space basis is a set of linear-independent basis vectors. (b) An abstract space basis can further be specialized by storing specialized basis vectors with additional attributes. By default, an abstract space basis is only characterized by its dimension. (c) Space basis may additionally include symmetry subranges, that is, contiguous ranges of basis vectors assigned a specific symmetry id.</p>
<p>ExaTN::Numerics: Register of vector spaces and their subspaces REVISION: 2019/06/06</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Register of vector spaces and their subspaces REVISION: 2019/06/06</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Any unregistered vector space has id = SOME_SPACE = 0 (anonymous vector space). A subspace of the anonymous vector space is defined by the base offset (first basis vector) and its dimension. (b) Any explicitly registered (named) vector space has id &gt; 0. (c) Any unregistered subspace of any registered vector space has id = UNREG_SUBSPACE = max(uint64_t). (d) Every named vector space has an automatically registered full subspace under the same (space) name with id = FULL_SUBSPACE = 0 (trivial subspace which spans the full space). (e) Every registered non-trivial subspace of any registered vector space has id: 0 &lt; id &lt; max(uint64_t).</p>
<p>ExaTN::Numerics: Spaces/Subspaces REVISION: 2019/07/07</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Spaces/Subspaces REVISION: 2019/06/06</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) An abstract vector space is defined by its dimension, N, making it a linear span of its N abstract basis vectors. Additonally, symmetry subranges can be defined within the space basis, that is, contiguous subranges of basis vectors can be assigned a specific symmetry id. (b) A specialized vector space is a span of linear-independent specialized basis vectors (specialized basis). (c) A subspace of a vector space is defined by its encompassing vector space and a range of basis vectors it is spanned over.</p>
<p>ExaTN::Numerics: Tensor REVISION: 2019/10/21</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Abstract Tensor REVISION: 2019/10/21</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) NOTES: Tensor specification requires: (a) Symbolic tensor name; (b) Tensor rank (number of tensor dimensions) and tensor shape (extents of all tensor dimensions); (c) Optional tensor signature (space/subspace identifier for all tensor dimensions). (d) Optional tensor element type (exatn::TensorElementType). (e) Optional isometries: An isometry is a group of tensor dimensions a contraction over which with the conjugated tensor results in a delta function over the remaining tensor dimensions, spit between the original and conjugated tensors. A tensor is isometric if it has at least one isometry group of dimensions. A tensor is unitary if its dimensions can be partioned into two non-overlapping groups such that both groups form an isometry.</p>
<p>Tensor signature identifies a full tensor or its slice. Tensor signature requires providing a pair&lt;SpaceId,SubspaceId&gt; for each tensor dimension. It has two alternative specifications: (a) SpaceId = SOME_SPACE: In this case, SubspaceId is the lower bound of the specified tensor slice (0 is the min lower bound). The upper bound is computed by adding the dimension extent to the lower bound - 1. The defining vector space (SOME_SPACE) is an abstract anonymous vector space. (b) SpaceId != SOME_SPACE: In this case, SpaceId refers to a registered vector space and the SubspaceId refers to a registered subspace of this vector space. The subspaces will carry lower/upper bounds of the specified tensor slice. SubspaceId = 0 refers to the full space, which is automatically registered when the space is registered. Although tensor dimension extents cannot exceed the dimensions of the corresponding registered subspaces from the tensor signature, they in general can be smaller than the latter (low-rank representation).</p>
<p>ExaTN: Tensor basic types and parameters REVISION: 2019/09/01</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor connected to other tensors inside a tensor network REVISION: 2019/10/16</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor connected to other tensors in a tensor network REVISION: 2019/10/16</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) A tensor inside a tensor network is generally connected to other tensors in that network via so-called tensor legs; each tensor leg is associated with a specific tensor dimension. (b) Each tensor leg specifies a connection of a given tensor dimension to some dimension (or dimensions) in another tensor (or tensors) in the same tensor network. Thus, tensor legs can be binary, ternary, etc., based on whether the tensor network is a graph or a hyper-graph. (c) The abstraction of a connected tensor is introduced for a quick inspection of the neighborhood of a chosen tensor inside the tensor network.</p>
<p>ExaTN::Numerics: Tensor network expansion REVISION: 2019/10/31</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor network expansion REVISION: 2019/10/31</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) A tensor network expansion is an ordered linear expansion consisting of tensor networks with complex coefficients. The output tensors of all constituting tensor networks must be congruent, that is, have the same shape and leg direction. The tensor network expansion is essentially a linear combination of tensor network vectors in a given tensor space. The rank of the tensor network expansion is the rank of the output tensors of all constituting tensor networks (they are the same). (b) A tensor network expansion can either be a ket or a bra. (c) An inner product tensor network expansion can be formed by contracting one tensor network expansion with another tensor network expansion from the dual vector space (bra*ket, ket*bra). (d) A direct product tensor network expansion can be formed from two tensor network expansions from the same space (bra*bra, ket*ket). (e) A tensor network operator can be applied to a tensor network expansion, producing another tensor network expansion in the same space.</p>
<p>ExaTN::Numerics: Tensor leg (connection) REVISION: 2019/10/21</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor leg (connection) REVISION: 2019/10/21</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) A tensor leg associates a tensor mode with a mode in another tensor by carrying the id of another tensor, its specific mode (position), and direction of the association.</p>
<p>ExaTN::Numerics: Tensor network REVISION: 2019/11/05</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor network REVISION: 2019/11/05</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) A tensor network is a set of connected tensors. Each tensor in a tensor network can be connected to other tensors in that tensor network via tensor legs. Each tensor leg in a given tensor is uniquely associated with one of its modes, one tensor leg per tensor mode. The numeration of tensor modes is contiguous and starts from 0. A tensor leg can connect a given tensor with one or more other tensors in the same tensor network. Thus, tensor legs can be binary, ternary, etc., in general (binary is common choice). (b) A tensor network is always closed, which requires introducing an explicit output tensor collecting all open legs of the original tensor network. If the original tensor network does not have open legs, the output tensor is simply a scalar which the original tensor network evaluates to; otherwise, a tensor network evaluates to a tensor. (c) Current tensor enumeration (it is just one option): 0: Output tensor/scalar which the tensor network evaluates to; 1..N: Input tensors/scalars constituting the original tensor network; N+1..M: Intermediate tensors obtained by contractions of the input tensors. In general, only the output tensor is required to have id = 0; any other tensor in the tensor network may have any unique positive id. (d) Building a tensor network: Option 1: A new tensor can be appended into a tensor network by either: (1) Explicitly matching the tensor modes with the modes of all other tensors present or to be present in the tensor network. The fully specified output tensor with all its legs has had to be provided in advance in the TensorNetwork ctor. This way requires the advance knowledge of the entire tensor network. Once all tensors have been appended, one needs to call .<a class="el" href="namespaceexatn.html#a6fd92b4f4f0e1d9d2506356f3b0bea10">finalize()</a> to complete the construction of the tensor network. (2) Matching the tensor modes with the modes of the current output tensor of the tensor network. In this case, the unmatched modes of the newly appended tensor will be appended to the current output tensor of the tensor network (at the end). Option 2: A tensor network can be appended to another tensor network by matching the modes of the output tensors of both tensor networks. The unmatched modes of the output tensor of the appended tensor network will be appended to the output tensor of the primary tensor network (at the end). The appended tensor network will cease to exist after being absorbed by the primary tensor network. (e) The modes of the output tensor of a tensor network can be examined and reordered. (f) Any tensor except the output tensor can be deleted from the tensor network. (g) Any two tensors, excluding the output tensor, can be merged by tensor contraction.</p>
<p>ExaTN::Numerics: Tensor operation: Adds a tensor to another tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor operation: Adds a tensor to another tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Adds a tensor to another tensor inside the processing backend.</p>
<p>ExaTN::Numerics: Tensor operation: Contracts two tensors and accumulates the result into another tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor operation: Contracts two tensors and accumulates the result into another tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Contracts two tensors and accumulates the result into another tensor inside the processing backend.</p>
<p>ExaTN::Numerics: Tensor operation: Creates a tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor operation: Creates a tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Creates a tensor inside the processing backend.</p>
<p>ExaTN::Numerics: Tensor operation: Destroys a tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor operation: Destroys a tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Destroys a tensor inside the processing backend.</p>
<p>ExaTN::Numerics: Tensor operation factory REVISION: 2019/09/10</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor operation factory REVISION: 2019/09/10</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Creates new tensor operations of desired kind.</p>
<p>ExaTN::Numerics: Tensor operation: Transforms/initializes a tensor REVISION: 2019/08/30</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor operation: Transforms/initializes a tensor REVISION: 2019/09/20</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Transforms/initializes a tensor inside the processing backend. Requires a user-provided talsh::TensorFunctor object to concretize the transformation/initilization operation.</p>
<p>ExaTN::Numerics: Tensor operation REVISION: 2019/10/13</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor operation REVISION: 2019/10/13</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) A tensor operation is a formal numerical operation on one or more tensors.</p>
<p>ExaTN::Numerics: Tensor operator REVISION: 2019/10/31</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor operator REVISION: 2019/10/31</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) A tensor network vector is a vector in a given tensor space with its expansion (tensor) coefficients factorized as a tensor network. A ket tensor network vector produces its corresponding dual bra tensor network vector upon complex conjugation of all constituting tensor factors and reversing the direction of the all tensor legs. (b) A tensor operator is an ordered linear combination of tensors and tensor networks in which the output tensor legs are distinguished as bra and ket tensor legs: The bra tensor legs contract with legs of a bra tensor network vector, the ket tensor legs contract with legs of a ket tensor network vector. (c) The first component of the tensor operator is applied first when acting on a ket vector. The last component of the tensor operator is applied first when acting on a bra vector. (d) The order of components of a tensor operator is reversed upon conjugation.</p>
<p>ExaTN::Numerics: Tensor shape REVISION: 2019/10/21</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor shape REVISION: 2019/10/21</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Tensor shape is an ordered set of tensor dimension extents. A scalar tensor (rank-0 tensor) has an empty shape.</p>
<p>ExaTN::Numerics: Tensor signature REVISION: 2019/10/21</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN::Numerics: Tensor signature REVISION: 2019/10/21</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle) Rationale: (a) Tensor signature is an ordered set of tensor dimension specifiers, that is, specifiers of the subspaces tensor dimensions are spanned over; (b) Registered signature: Tensor dimension specifier consists of a Space Id and a Subspace Id, thus associating the tensor dimension with a specific registered subspace of a specific registered vector space. (c) Anonymous signature: Tensor dimension specifier consists of the Space Id = SOME_SPACE, while the Subspace Id specifies the offset (first basis vector) in SOME_SPACE.</p>
<p>ExaTN: Numerics: Symbolic tensor processing REVISION: 2019/09/12</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN: Numerics: Symbolic tensor processing REVISION: 2019/09/11</p>
<p>Copyright (C) 2018-2019 Dmitry I. Lyakh (Liakh) Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale: (a) Valid symbolic tensor formats are (angle brackets mark placeholders for tokens): (1) Scalar (rank-0 tensor): &lt;TensorName&gt;&lt;+&gt;() Examples: S(), T+() (2) Tensor in an orthogonal basis: &lt;TensorName&gt;&lt;+&gt;(&lt;label&gt;,&lt;label&gt;,...) Examples: Q(i1,a1), H+(p1,p2,q1,q2) (3) &lt;TensorName&gt;&lt;+&gt;(&lt;label&gt;,&lt;label&gt;,...|&lt;label&gt;,&lt;label&gt;,...) Examples: Q(i1|a1), H+(p1,p2|q1,q2), R12(|a1,i3), L21(i1,b2|) where &lt;TensorName&gt; is an alphanumeric_ tensor name beginning with a letter; &lt;+&gt; is an optional complex conjugation sign; &lt;label&gt; is an alphanumeric_ index label beginning with a letter; In case the "|" separator is absent, all tensor indices are considered invariant, corresponding to undirected tensor legs (orthogonal basis). In case the "|" separator is present, tensor indices prior to "|" are considered contravariant, corresponding to OUTWARD tensor legs, whereas tensor indices after "|" are considered covariant, corresponding to INWARD tensor legs (this distinction becomes essential in non-orthogonal bases). (b) Valid symbolic tensor network formats: (a) &lt;OutputTensor&gt; = &lt;InputTensor&gt; * &lt;InputTensor&gt; * ... * &lt;InputTensor&gt; (b) &lt;OutputTensor&gt; += &lt;InputTensor&gt; * &lt;InputTensor&gt; * ... * &lt;InputTensor&gt; The number of tensors on the right-hand side is one or more.</p>
<p>ExaTN:: Tensor Runtime: Tensor graph executor: Eager REVISION: 2019/10/16</p>
<p>Copyright (C) 2018-2019 Tiffany Mintz, Dmitry Lyakh, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN:: Tensor Runtime: Tensor graph executor: Eager REVISION: 2019/10/04</p>
<p>Copyright (C) 2018-2019 Tiffany Mintz, Dmitry Lyakh, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale:</p>
<p>ExaTN:: Tensor Runtime: Tensor graph executor: Lazy REVISION: 2019/10/04</p>
<p>Copyright (C) 2018-2019 Dmitry Lyakh, Tiffany Mintz, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale:</p>
<p>ExaTN:: Tensor Runtime: Tensor graph node executor: Exatensor REVISION: 2019/10/04</p>
<p>Copyright (C) 2018-2019 Dmitry Lyakh, Tiffany Mintz, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN:: Tensor Runtime: Tensor graph node executor: Exatensor REVISION: 2019/10/04</p>
<p>Copyright (C) 2018-2019 Dmitry Lyakh, Tiffany Mintz, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale:</p>
<p>ExaTN:: Tensor Runtime: Tensor graph node executor: Talsh REVISION: 2019/10/07</p>
<p>Copyright (C) 2018-2019 Dmitry Lyakh, Tiffany Mintz, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN:: Tensor Runtime: Tensor graph node executor: Talsh REVISION: 2019/10/07</p>
<p>Copyright (C) 2018-2019 Dmitry Lyakh, Tiffany Mintz, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale:</p>
<p>ExaTN:: Tensor Runtime: Tensor graph executor REVISION: 2019/10/13</p>
<p>Copyright (C) 2018-2019 Dmitry Lyakh, Tiffany Mintz, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale: (a) Tensor graph executor traverses the tensor graph (DAG) and executes all its nodes while respecting node dependencies. Each DAG node is executed by a concrete tensor node executor (tensor operation stored in the DAG node accepts a polymorphic tensor node executor which then executes that tensor operation). The execution of each DAG node is generally asynchronous.</p>
<p>ExaTN:: Tensor Runtime: Tensor graph execution state REVISION: 2019/10/16</p>
<p>Copyright (C) 2018-2019 Dmitry Lyakh, Tiffany Mintz, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN:: Tensor Runtime: Tensor graph execution state REVISION: 2019/10/16</p>
<p>Copyright (C) 2018-2019 Dmitry Lyakh, Tiffany Mintz, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale: (a) Tensor graph is a directed acyclic graph in which vertices represent tensor operations and directed edges represent dependencies between them: A directed edge from node1 to node2 indicates that node1 depends on node2. Each DAG node has its unique integer vertex id (VertexIdType) returned when the node is appended into the DAG. (b) The tensor graph contains: 1. The DAG implementation (DirectedBoostGraph subclass); 2. The DAG execution state (TensorExecState data member). (c) The execution state of each Tensor in the DAG is either of the following: 1. None (no outstanding reads or writes on the Tensor); 2. Read (one or more most recently submitted tensor operations involving the Tensor perform reads on it). This is the READ epoch characterized by a positive integer equal to the number of outstanding reads on the Tensor in the current (read) epoch. 3. Write (most recent tensor operation on the Tensor is a write). This is the WRITE epoch characterized by a negative integer -1 denoting the single outstanding write on the Tensor in the current (write) epoch. The execution state of a Tensor is progressing through alternating read and write epochs, introducing read-after-write, write-after-write, and write-after-read dependencies between tensor nodes with stored tensor operations operating on the same data (Tensor). Importantly, the execution state of a Tensor is defined with respect to the DAG builder, that is, every time a new tensor operation is added into the DAG the execution state of each participating tensor is inspected and possibly altered (switched to another epoch). Thus, the execution state of a tensor is only used for establishing data dependencies for newly added DAG nodes, it has nothing to do with actual DAG execution.</p>
<p>ExaTN:: Tensor Runtime: Directed acyclic graph (DAG) of tensor operations REVISION: 2019/10/29</p>
<p>Copyright (C) 2018-2019 Tiffany Mintz, Dmitry Lyakh, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale: (a) The execution space consists of one or more DAGs in which nodes represent tensor operations (tasks) and directed edges represent dependencies between the corresponding nodes (tensor operations). Each DAG is associated with a uniquely named TAProL scope such that all tensor operations submitted by the Client to the ExaTN numerical server are forwarded into the DAG associated with the TaProL scope in which the Client currently resides. (b) The tensor graph contains: 1. The DAG implementation (in the DirectedBoostGraph subclass); 2. The DAG execution state (TensorExecState data member). (c) DEVELOPERS ONLY: The TensorGraph object provides lock/unlock methods for concurrent update of the DAG structure (by Client thread) and its execution state (by Execution thread). Public virtual methods of TensorGraph implemented in the DirectedBoostGraph subclass perform locking/unlocking from there. Other (non-virtual) public methods of TensorGraph perform locking/unlocking from here. Additionally each node of the TensorGraph (TensorOpNode object) provides more fine grained locking mechanism (lock/unlock methods) for providing exclusive access to individual DAG nodes, which is only related to TensorOpNode.getOperation() method since it returns a reference to the stored tensor operation (shared pointer reference), thus may require external locking for securing an exclusive access to this data member of TensorOpNode.</p>
<p>ExaTN:: Tensor Runtime: Task-based execution layer for tensor operations REVISION: 2019/10/20</p>
<p>Copyright (C) 2018-2019 Tiffany Mintz, Dmitry Lyakh, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>ExaTN:: Tensor Runtime: Task-based execution layer for tensor operations REVISION: 2019/10/29</p>
<p>Copyright (C) 2018-2019 Tiffany Mintz, Dmitry Lyakh, Alex McCaskey Copyright (C) 2018-2019 Oak Ridge National Laboratory (UT-Battelle)</p>
<p>Rationale: (a) The execution space consists of one or more DAGs in which nodes represent tensor operations (tasks) and directed edges represent dependencies between the corresponding nodes (tensor operations). Each DAG is associated with a uniquely named TAProL scope such that all tensor operations submitted by the Client to the ExaTN numerical server are forwarded into the DAG associated with the TaProL scope in which the Client currently resides. (b) The DAG lifecycle: openScope(name): Opens a new TAProL scope and creates its associated empty DAG. The .submit method can then be used to append new tensor operations or whole tensor networks into the current DAG. The actual execution of the submitted tensor operations is asynchronous and may start any time after submission. pauseScope(): Completes the actual execution of all started tensor operations in the current DAG and defers the execution of the rest of the DAG for later. resumeScope(name): Pauses the execution of the currently active DAG (if any) and resumes the execution of a previously paused DAG, making it current. <a class="el" href="namespaceexatn.html#a4c4b202ad14cc3dfab51344bcabbaac8">closeScope()</a>: Completes all tensor operations in the current DAG and destroys it. (c) submit(TensorOperation): Submits a tensor operation for (generally deferred) execution. sync(TensorOperation): Tests for completion of a specific tensor operation. sync(tensor): Tests for completion of all submitted update operations on a given tensor. (d) Upon creation, the TensorRuntime object spawns an execution thread which will be executing tensor operations in the course of DAG traversal. The execution thread will be joined upon TensorRuntime destruction. After spawning the execution thread, the main thread returns control to the client which will then be able to submit new operations into the current DAG. The submitted operations will be autonomously executed by the execution thread. The DAG execution policy is specified by a polymorphic TensorGraphExecutor provided during the construction of the TensorRuntime. Correspondingly, the TensorGraphExecutor contains a polymorphic TensorNodeExecutor responsible for the actual execution of submitted tensor operations via an associated computational backend. The concrete TensorNodeExecutor is specified during the construction of the TensorRuntime oject. (e) DEVELOPERS ONLY: The TensorGraph object (DAG) provides lock/unlock methods for concurrent update of the DAG structure (by Client thread) and its execution state (by Execution thread). Additionally each node of the TensorGraph (TensorOpNode object) provides more fine grain locking mechanism (lock/unlock methods) for providing exclusive access to individual DAG nodes. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a016e6da532f7a0b0cdcfaecd7c03b691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016e6da532f7a0b0cdcfaecd7c03b691">&#9670;&nbsp;</a></span>addTensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::addTensors </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericType&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs tensor addition: tensor0 += tensor1 * alpha </p>

</div>
</div>
<a id="a4c4b202ad14cc3dfab51344bcabbaac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4b202ad14cc3dfab51344bcabbaac8">&#9670;&nbsp;</a></span>closeScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ScopeId exatn::closeScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes the currently open TAProL scope and returns its parental scope id. </p>

</div>
</div>
<a id="a090bcde53c17135a666ca7bcb7d61514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090bcde53c17135a666ca7bcb7d61514">&#9670;&nbsp;</a></span>contractTensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::contractTensors </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericType&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs tensor contraction: tensor0 += tensor1 * tensor2 * alpha </p>

</div>
</div>
<a id="a0547f5ec3f31241b4e40bf2ce9214503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0547f5ec3f31241b4e40bf2ce9214503">&#9670;&nbsp;</a></span>createSubspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SubspaceId exatn::createSubspace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subspace_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>space_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; DimOffset, DimOffset &gt;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexatn_1_1numerics_1_1_subspace.html">Subspace</a> **&#160;</td>
          <td class="paramname"><em>subspace_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a named subspace of a named vector space, returns its registered id, and, optionally, a non-owning pointer to it. </p>

</div>
</div>
<a id="ae2b73d905fe974d4aa76b0548f4d4d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b73d905fe974d4aa76b0548f4d4d81">&#9670;&nbsp;</a></span>createTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::createTensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TensorElementType&#160;</td>
          <td class="paramname"><em>element_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declares, registers and actually creates a tensor via processing backend. See <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">numerics::Tensor</a> constructors for different creation options. </p>

</div>
</div>
<a id="ad3dc38482f24343564a16e08609775b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dc38482f24343564a16e08609775b9">&#9670;&nbsp;</a></span>createVectorSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpaceId exatn::createVectorSpace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>space_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DimExtent&#160;</td>
          <td class="paramname"><em>space_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexatn_1_1numerics_1_1_vector_space.html">VectorSpace</a> **&#160;</td>
          <td class="paramname"><em>space_ptr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a named vector space, returns its registered id, and, optionally, a non-owning pointer to it. </p>

</div>
</div>
<a id="a62396b5a34699a0e926b4ea7e0b74754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62396b5a34699a0e926b4ea7e0b74754">&#9670;&nbsp;</a></span>destroySubspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::destroySubspace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subspace_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys a previously created named subspace of a named vector space. </p>

</div>
</div>
<a id="a6ee1c97d99ad2562cd8b01d992b49983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee1c97d99ad2562cd8b01d992b49983">&#9670;&nbsp;</a></span>destroyTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::destroyTensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys a tensor, including its backend representation. </p>

</div>
</div>
<a id="ac890d1557b624fd402aa6e0d1cef0892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac890d1557b624fd402aa6e0d1cef0892">&#9670;&nbsp;</a></span>destroyVectorSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::destroyVectorSpace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>space_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys a previously created named vector space. </p>

</div>
</div>
<a id="aaba81ab31482f2d11c2b682c7d71960a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba81ab31482f2d11c2b682c7d71960a">&#9670;&nbsp;</a></span>evaluateTensorNetwork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::evaluateTensorNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>network</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a full evaluation of a tensor network. </p>

</div>
</div>
<a id="a6fd92b4f4f0e1d9d2506356f3b0bea10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd92b4f4f0e1d9d2506356f3b0bea10">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes ExaTN </p>

</div>
</div>
<a id="a0d0510df740154601b225ca85e7dee38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0510df740154601b225ca85e7dee38">&#9670;&nbsp;</a></span>generate_contraction_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::generate_contraction_pattern </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_leg.html">numerics::TensorLeg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>left_tensor_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>right_tensor_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>symb_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates symbolic tensor contraction pattern from the digital tensor contraction pattern used by the contraction-based Tensor constructor: pattern[0..m-1] describes connectivity of dimensions of the left contracted tensor, pattern[m..m+n-1] decribes connectivity of dimensions of the right contracted tensor, where m and n are the ranks of the left and right contracted tensors, respectively. pattern[x] is a TensorLeg specifying the dimension of another tensor the described dimension is connected to, where the result tensor is tensor 0 while the left and right contracted tensors are tensors 1 and 2, respectively. </p>

</div>
</div>
<a id="ad4a798d344b2b0498e9b391beb75d5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a798d344b2b0498e9b391beb75d5ab">&#9670;&nbsp;</a></span>getExternalData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;BytePacket&gt; exatn::getExternalData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves a registered external data packet. </p>

</div>
</div>
<a id="a0068c03bc225d84db8f1ca68ae840eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0068c03bc225d84db8f1ca68ae840eb3">&#9670;&nbsp;</a></span>getLocalTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;talsh::Tensor&gt; exatn::getLocalTensor </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; DimOffset, DimExtent &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a locally stored tensor slice (talsh::Tensor) providing access to tensor elements. This slice will be extracted from the <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">exatn::numerics::Tensor</a> implementation as a copy. The returned future becomes ready once the execution thread has retrieved the slice copy. </p>

</div>
</div>
<a id="aaaaf7496e85cf32c9527446a301a0d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaf7496e85cf32c9527446a301a0d7e">&#9670;&nbsp;</a></span>getSubspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classexatn_1_1numerics_1_1_subspace.html">Subspace</a>* exatn::getSubspace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subspace_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a non-owning pointer to a previosuly registered named subspace of a previously registered named vector space. </p>

</div>
</div>
<a id="af5fb913109ede1f468b042e4cadab54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fb913109ede1f468b042e4cadab54d">&#9670;&nbsp;</a></span>getTensorElementType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TensorElementType exatn::getTensorElementType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the tensor element type. </p>

</div>
</div>
<a id="a32b240460e27c268690079df15a59d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b240460e27c268690079df15a59d61">&#9670;&nbsp;</a></span>getTensorMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;TensorMethod&gt; exatn::getTensorMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves a registered external tensor method. </p>

</div>
</div>
<a id="a0a4bc55caa2a969395346eb2a631f451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4bc55caa2a969395346eb2a631f451">&#9670;&nbsp;</a></span>getTensorRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a>&amp; exatn::getTensorRef </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the reference to the actual tensor object. </p>

</div>
</div>
<a id="ab550fa106525e19be9a64935d268fc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab550fa106525e19be9a64935d268fc1d">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes ExaTN </p>

</div>
</div>
<a id="aa9b523e619187267d1e0d1b27f223176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b523e619187267d1e0d1b27f223176">&#9670;&nbsp;</a></span>initTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::initTensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericType&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a tensor to some scalar value. </p>

</div>
</div>
<a id="a1e5dacc9ac63031177dc1d1cba0d1a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5dacc9ac63031177dc1d1cba0d1a5f">&#9670;&nbsp;</a></span>is_alphanumeric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::is_alphanumeric </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns TRUE if the symbolic identifier is alphanumeric_ and starts with a letter. </p>

</div>
</div>
<a id="a387de899852d3210f660e682dc6a6430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387de899852d3210f660e682dc6a6430">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not ExaTN has been initialized </p>

</div>
</div>
<a id="a2a1df2c9622ad4a0d42f511a7e4adccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1df2c9622ad4a0d42f511a7e4adccb">&#9670;&nbsp;</a></span>openScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ScopeId exatn::openScope </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>scope_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens a new (child) TAProL scope and returns its id. </p>

</div>
</div>
<a id="ac376ebab37a06ba798a1a3510e51e47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac376ebab37a06ba798a1a3510e51e47a">&#9670;&nbsp;</a></span>parse_tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::parse_tensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>tensor_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structexatn_1_1_index_label.html">IndexLabel</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>complex_conjugated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the tensor parses as a valid symbolic tensor. The output function parameters will contain parsed tokens. </p>

</div>
</div>
<a id="aa525a333d893eb552bf62eb6a408948b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa525a333d893eb552bf62eb6a408948b">&#9670;&nbsp;</a></span>parse_tensor_network()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::parse_tensor_network </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the tensor network parses as a valid symbolic tensor network. The output std::vector returns parsed symbolic tensors where element #0 is the output tensor of the tensor network. </p>

</div>
</div>
<a id="a6e70ee2bed4171c189d6959369c11d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e70ee2bed4171c189d6959369c11d21">&#9670;&nbsp;</a></span>registerExternalData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::registerExternalData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; BytePacket &gt;&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers an external data packet. </p>

</div>
</div>
<a id="a4c5f19d66b02decec304d8129342ac51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5f19d66b02decec304d8129342ac51">&#9670;&nbsp;</a></span>registerTensorMethod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::registerTensorMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; TensorMethod &gt;&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers an external tensor method. </p>

</div>
</div>
<a id="a93b4de20386d3fc968baadd35eecd88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b4de20386d3fc968baadd35eecd88c">&#9670;&nbsp;</a></span>resetRuntimeLoggingLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::resetRuntimeLoggingLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets tensor runtime logging level (0:none). </p>

</div>
</div>
<a id="a6b9fb65f20c69d23cdf69b4f3acf9ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9fb65f20c69d23cdf69b4f3acf9ed1">&#9670;&nbsp;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::sync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronizes all outstanding update operations on a given tensor. </p>

</div>
</div>
<a id="a71d4ce03b21b91126d7381ea5fc318b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d4ce03b21b91126d7381ea5fc318b8">&#9670;&nbsp;</a></span>transformTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::transformTensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; TensorMethod &gt;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms (updates) a tensor according to a user-defined tensor functor. </p>

</div>
</div>
<a id="a443ef2ec833fd6bccf065aeb0b760d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443ef2ec833fd6bccf065aeb0b760d6d">&#9670;&nbsp;</a></span>trim_spaces_off()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int,int&gt; exatn::trim_spaces_off </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the string view range without leading and trailing spaces. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a195b193ef5b91bdba6382ae874f93893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195b193ef5b91bdba6382ae874f93893">&#9670;&nbsp;</a></span>numericalServer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classexatn_1_1_num_server.html">NumServer</a> &gt; exatn::numericalServer {nullptr}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Numerical server (singleton)</p>
<p>Numerical service singleton (numerical server) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
