<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ExaTN: exatn::numerics::TensorNetwork Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ExaTN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceexatn.html">exatn</a></li><li class="navelem"><b>numerics</b></li><li class="navelem"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classexatn_1_1numerics_1_1_tensor_network-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">exatn::numerics::TensorNetwork Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a02aa967ed1500f74dc11e479595918f8"><td class="memItemLeft" align="right" valign="top"><a id="a02aa967ed1500f74dc11e479595918f8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Iterator</b> = typename std::unordered_map&lt; unsigned int, <a class="el" href="classexatn_1_1numerics_1_1_tensor_conn.html">TensorConn</a> &gt;::iterator</td></tr>
<tr class="separator:a02aa967ed1500f74dc11e479595918f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95edb27bcf880afaab14bfc49eb6da8"><td class="memItemLeft" align="right" valign="top"><a id="ae95edb27bcf880afaab14bfc49eb6da8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstIterator</b> = typename std::unordered_map&lt; unsigned int, <a class="el" href="classexatn_1_1numerics_1_1_tensor_conn.html">TensorConn</a> &gt;::const_iterator</td></tr>
<tr class="separator:ae95edb27bcf880afaab14bfc49eb6da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf20817ffd709a3c0c3e5cae6dbc9908"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#acf20817ffd709a3c0c3e5cae6dbc9908">TensorNetwork</a> ()</td></tr>
<tr class="separator:acf20817ffd709a3c0c3e5cae6dbc9908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467d885e49e507a6f9726910b5622476"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a467d885e49e507a6f9726910b5622476">TensorNetwork</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a467d885e49e507a6f9726910b5622476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8893509ecafa3583b5804a5fccddc94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#ae8893509ecafa3583b5804a5fccddc94">TensorNetwork</a> (const std::string &amp;name, std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt; output_tensor, const std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_leg.html">TensorLeg</a> &gt; &amp;output_legs)</td></tr>
<tr class="separator:ae8893509ecafa3583b5804a5fccddc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab62f4dec0d45865998c6f4628ff366"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a5ab62f4dec0d45865998c6f4628ff366">TensorNetwork</a> (const std::string &amp;name, const std::string &amp;tensor_network, const std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&gt; &amp;tensors)</td></tr>
<tr class="separator:a5ab62f4dec0d45865998c6f4628ff366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2586b2243bf03cb34a6666fdcebdaa98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a2586b2243bf03cb34a6666fdcebdaa98">TensorNetwork</a> (const std::string &amp;name, std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt; output_tensor, <a class="el" href="classexatn_1_1numerics_1_1_network_builder.html">NetworkBuilder</a> &amp;builder)</td></tr>
<tr class="separator:a2586b2243bf03cb34a6666fdcebdaa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5204679a91f29582d421c70fcc57d68"><td class="memItemLeft" align="right" valign="top"><a id="af5204679a91f29582d421c70fcc57d68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorNetwork</b> (const <a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;)=default</td></tr>
<tr class="separator:af5204679a91f29582d421c70fcc57d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c177b99cdf0a78acf7cd592fe5ccef5"><td class="memItemLeft" align="right" valign="top"><a id="a8c177b99cdf0a78acf7cd592fe5ccef5"></a>
<a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;)=default</td></tr>
<tr class="separator:a8c177b99cdf0a78acf7cd592fe5ccef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ea3cdc23da2d3efefd541f9914f70a"><td class="memItemLeft" align="right" valign="top"><a id="a52ea3cdc23da2d3efefd541f9914f70a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorNetwork</b> (<a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a52ea3cdc23da2d3efefd541f9914f70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88898bef31ab4470d88579a2feb23e10"><td class="memItemLeft" align="right" valign="top"><a id="a88898bef31ab4470d88579a2feb23e10"></a>
<a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a88898bef31ab4470d88579a2feb23e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a15e8a45dad101d2cb8a6bb89838ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a1a15e8a45dad101d2cb8a6bb89838ae7">printIt</a> () const</td></tr>
<tr class="separator:a1a15e8a45dad101d2cb8a6bb89838ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f451f9ca1ac768f623daac2c1aa210"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a62f451f9ca1ac768f623daac2c1aa210">isEmpty</a> () const</td></tr>
<tr class="separator:a62f451f9ca1ac768f623daac2c1aa210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c3c94def8db7e9a9735a69aca65b0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#ab2c3c94def8db7e9a9735a69aca65b0f">isExplicit</a> () const</td></tr>
<tr class="separator:ab2c3c94def8db7e9a9735a69aca65b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad67900f454c45f17efcc07d7f99d021"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#aad67900f454c45f17efcc07d7f99d021">isFinalized</a> () const</td></tr>
<tr class="separator:aad67900f454c45f17efcc07d7f99d021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13ea6f4e73d5a25d5cd5ad7d3bc51e7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#af13ea6f4e73d5a25d5cd5ad7d3bc51e7">getRank</a> () const</td></tr>
<tr class="separator:af13ea6f4e73d5a25d5cd5ad7d3bc51e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64500cd467ade21fb684f60905cd36cb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a64500cd467ade21fb684f60905cd36cb">getNumTensors</a> () const</td></tr>
<tr class="separator:a64500cd467ade21fb684f60905cd36cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11587a3b2f2113f73c2e55d0c0b80365"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a11587a3b2f2113f73c2e55d0c0b80365">getMaxTensorId</a> () const</td></tr>
<tr class="separator:a11587a3b2f2113f73c2e55d0c0b80365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15145c43dd468a9a37fb4a13cda88b8"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#af15145c43dd468a9a37fb4a13cda88b8">getName</a> () const</td></tr>
<tr class="separator:af15145c43dd468a9a37fb4a13cda88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a66bdaf7568a61075a89cadd8cc4a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a4a66bdaf7568a61075a89cadd8cc4a45">rename</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a4a66bdaf7568a61075a89cadd8cc4a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af090d056e949c76b2405b1a443d49d01"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#af090d056e949c76b2405b1a443d49d01">getTensor</a> (unsigned int tensor_id, bool *conjugated=nullptr)</td></tr>
<tr class="separator:af090d056e949c76b2405b1a443d49d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad8e72b29a13d2d6266d1eed1a02fd0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_leg.html">TensorLeg</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a1ad8e72b29a13d2d6266d1eed1a02fd0">getTensorConnections</a> (unsigned int tensor_id)</td></tr>
<tr class="separator:a1ad8e72b29a13d2d6266d1eed1a02fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92212af0b8808cfbd5b54b491001d20"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#ab92212af0b8808cfbd5b54b491001d20">begin</a> ()</td></tr>
<tr class="separator:ab92212af0b8808cfbd5b54b491001d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5233d8fb8ed265067f2321a924ab1992"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a5233d8fb8ed265067f2321a924ab1992">end</a> ()</td></tr>
<tr class="separator:a5233d8fb8ed265067f2321a924ab1992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a4f9a45e93cb26bcd84d35bb299b89"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#af4a4f9a45e93cb26bcd84d35bb299b89">cbegin</a> () const</td></tr>
<tr class="separator:af4a4f9a45e93cb26bcd84d35bb299b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c908e8d895726607a3aed59a2f5225f"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a3c908e8d895726607a3aed59a2f5225f">cend</a> () const</td></tr>
<tr class="separator:a3c908e8d895726607a3aed59a2f5225f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f35282e7d2e67e92408eef88e51f03e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a5f35282e7d2e67e92408eef88e51f03e">finalize</a> (bool check_validity=false)</td></tr>
<tr class="separator:a5f35282e7d2e67e92408eef88e51f03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5861287dff96bccaaad24bfc8a396e21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a5861287dff96bccaaad24bfc8a396e21">appendTensor</a> (unsigned int tensor_id, std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt; tensor, const std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_leg.html">TensorLeg</a> &gt; &amp;connections, bool conjugated=false, bool leg_matching_check=true)</td></tr>
<tr class="separator:a5861287dff96bccaaad24bfc8a396e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08da5083be7a8abbf7d661c8c13e3474"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a08da5083be7a8abbf7d661c8c13e3474">appendTensor</a> (unsigned int tensor_id, std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt; tensor, const std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt;&gt; &amp;pairing, const std::vector&lt; LegDirection &gt; &amp;leg_dir=std::vector&lt; LegDirection &gt;{}, bool conjugated=false)</td></tr>
<tr class="separator:a08da5083be7a8abbf7d661c8c13e3474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c0d8fbb29c175f621ef571f18db7bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a38c0d8fbb29c175f621ef571f18db7bb">appendTensorGate</a> (unsigned int tensor_id, std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt; tensor, const std::vector&lt; unsigned int &gt; &amp;pairing, bool conjugated=false)</td></tr>
<tr class="separator:a38c0d8fbb29c175f621ef571f18db7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ebdf1cd0e9c5aacd3cd81ed3303157"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a62ebdf1cd0e9c5aacd3cd81ed3303157">appendTensorNetwork</a> (<a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;&amp;network, const std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt;&gt; &amp;pairing)</td></tr>
<tr class="separator:a62ebdf1cd0e9c5aacd3cd81ed3303157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede07f2f7b890ee3ba467a8be03c9a53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#aede07f2f7b890ee3ba467a8be03c9a53">appendTensorNetworkGate</a> (<a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;&amp;network, const std::vector&lt; unsigned int &gt; &amp;pairing)</td></tr>
<tr class="separator:aede07f2f7b890ee3ba467a8be03c9a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc030f9be2ec25192ba5e132b9c7fd6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#acc030f9be2ec25192ba5e132b9c7fd6c">reorderOutputModes</a> (const std::vector&lt; unsigned int &gt; &amp;order)</td></tr>
<tr class="separator:acc030f9be2ec25192ba5e132b9c7fd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20bc31a9ac48f3a4286bb4be2ba979c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#aa20bc31a9ac48f3a4286bb4be2ba979c">deleteTensor</a> (unsigned int tensor_id)</td></tr>
<tr class="separator:aa20bc31a9ac48f3a4286bb4be2ba979c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9cd71a60b5351b935a07a26afe249b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a3b9cd71a60b5351b935a07a26afe249b">mergeTensors</a> (unsigned int left_id, unsigned int right_id, unsigned int result_id, std::string *contr_pattern=nullptr)</td></tr>
<tr class="separator:a3b9cd71a60b5351b935a07a26afe249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d33cfd980a6a500308b539009ba6de5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a4d33cfd980a6a500308b539009ba6de5">splitTensor</a> (unsigned int tensor_id, unsigned int left_tensor_id, const std::string &amp;left_tensor_name, unsigned int right_tensor_id, const std::string &amp;right_tensor_name, const <a class="el" href="classexatn_1_1numerics_1_1_tensor_shape.html">TensorShape</a> &amp;contracted_dims, const std::vector&lt; int &gt; &amp;right_dims)</td></tr>
<tr class="separator:a4d33cfd980a6a500308b539009ba6de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f08f7581950419509092708f7c4efe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a07f08f7581950419509092708f7c4efe">conjugate</a> ()</td></tr>
<tr class="separator:a07f08f7581950419509092708f7c4efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd1c458a107afc63e5841f72d460919"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a3dd1c458a107afc63e5841f72d460919">getContractionCost</a> (unsigned int left_id, unsigned int right_id, double *arithm_intensity=nullptr, bool adjust_cost=false)</td></tr>
<tr class="separator:a3dd1c458a107afc63e5841f72d460919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62de3bd4b1a3750c92d415d03ccb95e0"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_operation.html">TensorOperation</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a62de3bd4b1a3750c92d415d03ccb95e0">getOperationList</a> (const std::string &amp;contr_seq_opt_name=&quot;dummy&quot;)</td></tr>
<tr class="separator:a62de3bd4b1a3750c92d415d03ccb95e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abda25ff446ef1fc34ea5d7a854f2f41c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classexatn_1_1numerics_1_1_tensor_conn.html">TensorConn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#abda25ff446ef1fc34ea5d7a854f2f41c">getTensorConn</a> (unsigned int tensor_id)</td></tr>
<tr class="separator:abda25ff446ef1fc34ea5d7a854f2f41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186aa8f2c851ae45d5312b65f5395061"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_conn.html">TensorConn</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a186aa8f2c851ae45d5312b65f5395061">getTensorConnAll</a> ()</td></tr>
<tr class="separator:a186aa8f2c851ae45d5312b65f5395061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f122e4ca9cd17373801ef538fb7f42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#af5f122e4ca9cd17373801ef538fb7f42">checkConnections</a> (unsigned int tensor_id)</td></tr>
<tr class="separator:af5f122e4ca9cd17373801ef538fb7f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2326de62f1218c4eb001e8c6f12bd76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#ac2326de62f1218c4eb001e8c6f12bd76">checkConnections</a> ()</td></tr>
<tr class="separator:ac2326de62f1218c4eb001e8c6f12bd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6644550662261f337af6cb0701445d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a6644550662261f337af6cb0701445d4d">updateConnections</a> (unsigned int tensor_id)</td></tr>
<tr class="separator:a6644550662261f337af6cb0701445d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2510ccdb4d8f85e75f8d4d855b1c593e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a2510ccdb4d8f85e75f8d4d855b1c593e">updateConnectionsFromInputTensors</a> ()</td></tr>
<tr class="separator:a2510ccdb4d8f85e75f8d4d855b1c593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48397437159bbc46eafcd74a714a7f8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a48397437159bbc46eafcd74a714a7f8b">invalidateContractionSequence</a> ()</td></tr>
<tr class="separator:a48397437159bbc46eafcd74a714a7f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812c5a736d18f4ef7f4dc9a92f79c39f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a812c5a736d18f4ef7f4dc9a92f79c39f">determineContractionSequence</a> (<a class="el" href="classexatn_1_1numerics_1_1_contraction_seq_optimizer.html">ContractionSeqOptimizer</a> &amp;contr_seq_optimizer)</td></tr>
<tr class="separator:a812c5a736d18f4ef7f4dc9a92f79c39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acf20817ffd709a3c0c3e5cae6dbc9908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf20817ffd709a3c0c3e5cae6dbc9908">&#9670;&nbsp;</a></span>TensorNetwork() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exatn::numerics::TensorNetwork::TensorNetwork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an unnamed empty tensor network with a single scalar output tensor named "_SMOKY_TENSOR_" </p>

</div>
</div>
<a id="a467d885e49e507a6f9726910b5622476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467d885e49e507a6f9726910b5622476">&#9670;&nbsp;</a></span>TensorNetwork() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exatn::numerics::TensorNetwork::TensorNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a named empty tensor network with a single scalar output tensor named with the same name. </p>

</div>
</div>
<a id="ae8893509ecafa3583b5804a5fccddc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8893509ecafa3583b5804a5fccddc94">&#9670;&nbsp;</a></span>TensorNetwork() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exatn::numerics::TensorNetwork::TensorNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>output_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_leg.html">TensorLeg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_legs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a named empty tensor network with an explicitly provided output tensor with the same name. </p>

</div>
</div>
<a id="a5ab62f4dec0d45865998c6f4628ff366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab62f4dec0d45865998c6f4628ff366">&#9670;&nbsp;</a></span>TensorNetwork() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exatn::numerics::TensorNetwork::TensorNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tensor_network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a named tensor network from a symbolic tensor network expression and a container of tensors. </p>

</div>
</div>
<a id="a2586b2243bf03cb34a6666fdcebdaa98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2586b2243bf03cb34a6666fdcebdaa98">&#9670;&nbsp;</a></span>TensorNetwork() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">exatn::numerics::TensorNetwork::TensorNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>output_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classexatn_1_1numerics_1_1_network_builder.html">NetworkBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a named tensor network from a template implemented by a custom tensor network builder. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08da5083be7a8abbf7d661c8c13e3474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08da5083be7a8abbf7d661c8c13e3474">&#9670;&nbsp;</a></span>appendTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::appendTensor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; LegDirection &gt; &amp;&#160;</td>
          <td class="paramname"><em>leg_dir</em> = <code>std::vector&lt;LegDirection&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjugated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a new tensor to the tensor network by matching the tensor modes with the modes of the output tensor of the tensor network. The unmatched modes of the newly appended tensor will be appended to the existing modes of the output tensor of the tensor network (at the end). The optional argument leg_dir allows specification of the leg direction for all tensor modes. If provided, the direction of the paired legs of the appended tensor must anti-match the direction of the corresponding legs of existing tensors. </p>

</div>
</div>
<a id="a5861287dff96bccaaad24bfc8a396e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5861287dff96bccaaad24bfc8a396e21">&#9670;&nbsp;</a></span>appendTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::appendTensor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_leg.html">TensorLeg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjugated</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leg_matching_check</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a new tensor to the tensor network by matching the tensor modes with the modes of other tensors present or to be present in the tensor network. The fully specified output tensor with all its legs has had to be provided in advance in the <a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> ctor. This way requires the advance knowledge of the entire tensor network. Once all tensors have been appended, one needs to call .<a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a5f35282e7d2e67e92408eef88e51f03e">finalize()</a> to complete the construction of the tensor network. </p>

</div>
</div>
<a id="a38c0d8fbb29c175f621ef571f18db7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c0d8fbb29c175f621ef571f18db7bb">&#9670;&nbsp;</a></span>appendTensorGate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::appendTensorGate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjugated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a new even-rank tensor to the tensor network by matching the first half of the tensor legs with network's output legs provided in "pairing". The second half of the tensor legs will then replace the matched output legs in the output tensor. </p>

</div>
</div>
<a id="a62ebdf1cd0e9c5aacd3cd81ed3303157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ebdf1cd0e9c5aacd3cd81ed3303157">&#9670;&nbsp;</a></span>appendTensorNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::appendTensorNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a tensor network to the current (primary) tensor network by matching the modes of the output tensors of both tensor networks. The unmatched modes of the output tensor of the appended tensor network will be appended to the updated output tensor of the primary tensor network (at the end). The appended tensor network will cease to exist after being absorbed by the primary tensor network. If paired legs of either output tensor are directed, the directions must be respected. The tensors constituting the appended tensor network, except its output tensor, must have their unique ids be different from the ids of the tensors constituting the primary tensor network, otherwise the result is undefined and unrecoverable! </p>

</div>
</div>
<a id="aede07f2f7b890ee3ba467a8be03c9a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede07f2f7b890ee3ba467a8be03c9a53">&#9670;&nbsp;</a></span>appendTensorNetworkGate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::appendTensorNetworkGate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html">TensorNetwork</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends an even-rank tensor network to the current (primary) tensor network by matching the first half of the output modes of the appended tensor network with selected modes of the current (primary) tensor network, simultaneously replacing the matched output modes of the current (primary) tensor network by the second half of the modes of the appended tensor network, going in order. Matching will respect leg directions. The replacing output modes of the appended tensor network mush have same directions as the replaced modes of the current (primary) tensor network. The appended tensor network will cease to exist after being absorbed by the primary tensor network. The tensors constituting the appended tensor network, except its output tensor, must have their unique ids be different from the ids of the tensors constituting the primary tensor network, otherwise the result is undefined and unrecoverable! </p>

</div>
</div>
<a id="ab92212af0b8808cfbd5b54b491001d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92212af0b8808cfbd5b54b491001d20">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator exatn::numerics::TensorNetwork::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin iterator </p>

</div>
</div>
<a id="af4a4f9a45e93cb26bcd84d35bb299b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a4f9a45e93cb26bcd84d35bb299b89">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator exatn::numerics::TensorNetwork::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begin constant iterator </p>

</div>
</div>
<a id="a3c908e8d895726607a3aed59a2f5225f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c908e8d895726607a3aed59a2f5225f">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator exatn::numerics::TensorNetwork::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End constant iterator </p>

</div>
</div>
<a id="ac2326de62f1218c4eb001e8c6f12bd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2326de62f1218c4eb001e8c6f12bd76">&#9670;&nbsp;</a></span>checkConnections() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::checkConnections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks validity of connections in the enitre tensor network. </p>

</div>
</div>
<a id="af5f122e4ca9cd17373801ef538fb7f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f122e4ca9cd17373801ef538fb7f42">&#9670;&nbsp;</a></span>checkConnections() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::checkConnections </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks validity of connections of a given tensor. </p>

</div>
</div>
<a id="a07f08f7581950419509092708f7c4efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f08f7581950419509092708f7c4efe">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::numerics::TensorNetwork::conjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conjugates the tensor network, which includes complex conjugation of all tensors as well as reversal of the direction of all tensor legs. </p>

</div>
</div>
<a id="aa20bc31a9ac48f3a4286bb4be2ba979c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20bc31a9ac48f3a4286bb4be2ba979c">&#9670;&nbsp;</a></span>deleteTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::deleteTensor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a tensor from a finalized tensor network (output tensor cannot be deleted). The released tensor legs will be joined at the end of the output tensor, unless a tensor leg was already connected to the output tensor, in which case it will be deleted completely, resulting in a reduced rank of the output tensor. </p>

</div>
</div>
<a id="a812c5a736d18f4ef7f4dc9a92f79c39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812c5a736d18f4ef7f4dc9a92f79c39f">&#9670;&nbsp;</a></span>determineContractionSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double exatn::numerics::TensorNetwork::determineContractionSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classexatn_1_1numerics_1_1_contraction_seq_optimizer.html">ContractionSeqOptimizer</a> &amp;&#160;</td>
          <td class="paramname"><em>contr_seq_optimizer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines a pseudo-optimal tensor contraction sequence required for evaluating the tensor network. Returns an estimate of the total flop count required by the returned contraction sequence. The tensor network must contain at least two input tensors in order to generate a single contraction. No contraction sequence is generated for tensor networks consisting of a single input tensor. </p>

</div>
</div>
<a id="a5233d8fb8ed265067f2321a924ab1992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5233d8fb8ed265067f2321a924ab1992">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator exatn::numerics::TensorNetwork::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End iterator </p>

</div>
</div>
<a id="a5f35282e7d2e67e92408eef88e51f03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f35282e7d2e67e92408eef88e51f03e">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::finalize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_validity</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalizes the explicit construction of the tensor network (construction with advance knowledge). The tensor network cannot be empty. </p>

</div>
</div>
<a id="a3dd1c458a107afc63e5841f72d460919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd1c458a107afc63e5841f72d460919">&#9670;&nbsp;</a></span>getContractionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double exatn::numerics::TensorNetwork::getContractionCost </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>left_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>right_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>arithm_intensity</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjust_cost</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the FMA flop count for a given contraction of two tensors identified by their ids in the tensor network. Optionally returns the arithmetic intensity of the tensor contraction as well. Additionally, it also allows rescaling of the tensor contraction cost with the adjustment by the arithmetic intensity (lower arithmetic intensity will increase the cost). </p>

</div>
</div>
<a id="a11587a3b2f2113f73c2e55d0c0b80365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11587a3b2f2113f73c2e55d0c0b80365">&#9670;&nbsp;</a></span>getMaxTensorId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int exatn::numerics::TensorNetwork::getMaxTensorId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximal tensor id value used in the tensor network. </p>

</div>
</div>
<a id="af15145c43dd468a9a37fb4a13cda88b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15145c43dd468a9a37fb4a13cda88b8">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; exatn::numerics::TensorNetwork::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the tensor network. </p>

</div>
</div>
<a id="a64500cd467ade21fb684f60905cd36cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64500cd467ade21fb684f60905cd36cb">&#9670;&nbsp;</a></span>getNumTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int exatn::numerics::TensorNetwork::getNumTensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of input tensors in the tensor network. Note that the output tensor (tensor #0) is not counted here. </p>

</div>
</div>
<a id="a62de3bd4b1a3750c92d415d03ccb95e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62de3bd4b1a3750c92d415d03ccb95e0">&#9670;&nbsp;</a></span>getOperationList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_operation.html">TensorOperation</a> &gt; &gt; &amp; exatn::numerics::TensorNetwork::getOperationList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contr_seq_opt_name</em> = <code>&quot;dummy&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the list of tensor operations required for evaluating the tensor network. </p>

</div>
</div>
<a id="af13ea6f4e73d5a25d5cd5ad7d3bc51e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13ea6f4e73d5a25d5cd5ad7d3bc51e7">&#9670;&nbsp;</a></span>getRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int exatn::numerics::TensorNetwork::getRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the rank of the tensor network (rank of its output tensor). </p>

</div>
</div>
<a id="af090d056e949c76b2405b1a443d49d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af090d056e949c76b2405b1a443d49d01">&#9670;&nbsp;</a></span>getTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor.html">Tensor</a> &gt; exatn::numerics::TensorNetwork::getTensor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>conjugated</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a given tensor of the tensor network without its connections (legs). If not found, returns nullptr. </p>

</div>
</div>
<a id="abda25ff446ef1fc34ea5d7a854f2f41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda25ff446ef1fc34ea5d7a854f2f41c">&#9670;&nbsp;</a></span>getTensorConn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexatn_1_1numerics_1_1_tensor_conn.html">TensorConn</a> * exatn::numerics::TensorNetwork::getTensorConn </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a non-owning pointer to a given tensor of the tensor network together with its connections (legs). If not found, returns nullptr. </p>

</div>
</div>
<a id="a186aa8f2c851ae45d5312b65f5395061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186aa8f2c851ae45d5312b65f5395061">&#9670;&nbsp;</a></span>getTensorConnAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_conn.html">TensorConn</a> * &gt; exatn::numerics::TensorNetwork::getTensorConnAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector of non-owning pointers to all tensors in the tensor network, except the output tensor. </p>

</div>
</div>
<a id="a1ad8e72b29a13d2d6266d1eed1a02fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad8e72b29a13d2d6266d1eed1a02fd0">&#9670;&nbsp;</a></span>getTensorConnections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classexatn_1_1numerics_1_1_tensor_leg.html">TensorLeg</a> &gt; * exatn::numerics::TensorNetwork::getTensorConnections </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get tensor connections. </p>

</div>
</div>
<a id="a48397437159bbc46eafcd74a714a7f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48397437159bbc46eafcd74a714a7f8b">&#9670;&nbsp;</a></span>invalidateContractionSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::numerics::TensorNetwork::invalidateContractionSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invalidates cached tensor contraction sequence. </p>

</div>
</div>
<a id="a62f451f9ca1ac768f623daac2c1aa210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f451f9ca1ac768f623daac2c1aa210">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the tensor network is empty, FALSE otherwise. </p>

</div>
</div>
<a id="ab2c3c94def8db7e9a9735a69aca65b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c3c94def8db7e9a9735a69aca65b0f">&#9670;&nbsp;</a></span>isExplicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::isExplicit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the tensor network is being built explicitly, FALSE otherwise. </p>

</div>
</div>
<a id="aad67900f454c45f17efcc07d7f99d021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad67900f454c45f17efcc07d7f99d021">&#9670;&nbsp;</a></span>isFinalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::isFinalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the tensor network is finalized, FALSE otherwise. </p>

</div>
</div>
<a id="a3b9cd71a60b5351b935a07a26afe249b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9cd71a60b5351b935a07a26afe249b">&#9670;&nbsp;</a></span>mergeTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::mergeTensors </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>left_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>right_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>result_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>contr_pattern</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merges two tensors in a finalized tensor network by replacing them by their contracted product: result = left * right: All participating tensor ids must be distinct and not equal to 0. The uncontracted modes of the left tensor will precede in-order the uncontracted modes of the right tensor in the tensor-result. </p>

</div>
</div>
<a id="a1a15e8a45dad101d2cb8a6bb89838ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a15e8a45dad101d2cb8a6bb89838ae7">&#9670;&nbsp;</a></span>printIt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::numerics::TensorNetwork::printIt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints </p>

</div>
</div>
<a id="a4a66bdaf7568a61075a89cadd8cc4a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a66bdaf7568a61075a89cadd8cc4a45">&#9670;&nbsp;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::numerics::TensorNetwork::rename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renames the tensor network. </p>

</div>
</div>
<a id="acc030f9be2ec25192ba5e132b9c7fd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc030f9be2ec25192ba5e132b9c7fd6c">&#9670;&nbsp;</a></span>reorderOutputModes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::reorderOutputModes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reorders the modes of the output tensor of the tensor network: order[x] = y: yth mode of the output tensor becomes its xth mode. </p>

</div>
</div>
<a id="a4d33cfd980a6a500308b539009ba6de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d33cfd980a6a500308b539009ba6de5">&#9670;&nbsp;</a></span>splitTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool exatn::numerics::TensorNetwork::splitTensor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>left_tensor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>left_tensor_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>right_tensor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>right_tensor_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexatn_1_1numerics_1_1_tensor_shape.html">TensorShape</a> &amp;&#160;</td>
          <td class="paramname"><em>contracted_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits a given tensor in a finalized tensor network into two tensors by introducing new dimensions across the cutting boundary. The original tensor dimensions are then assigned to either left or right tensor. The new dimensions are then appended to both tensors at the end. The two tensors obtained via such splitting must get unique ids, one of them may be the original tensor_id. </p>

</div>
</div>
<a id="a6644550662261f337af6cb0701445d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6644550662261f337af6cb0701445d4d">&#9670;&nbsp;</a></span>updateConnections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::numerics::TensorNetwork::updateConnections </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tensor_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates tensor network linking when a tensor has its connections modified: tensor_id is the id of the tensor whose leg numeration was updated. </p>

</div>
</div>
<a id="a2510ccdb4d8f85e75f8d4d855b1c593e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2510ccdb4d8f85e75f8d4d855b1c593e">&#9670;&nbsp;</a></span>updateConnectionsFromInputTensors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void exatn::numerics::TensorNetwork::updateConnectionsFromInputTensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls <a class="el" href="classexatn_1_1numerics_1_1_tensor_network.html#a6644550662261f337af6cb0701445d4d">updateConnections()</a> method for all input tensors. This is used for updating the output tensor legs. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/aqw/exatn/src/numerics/<a class="el" href="tensor__network_8hpp_source.html">tensor_network.hpp</a></li>
<li>/Users/aqw/exatn/src/numerics/tensor_network.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
